import sys
import os
import pathlib 
import argparse
import shutil
import time
from distutils.dir_util import copy_tree
import numpy as np
from collections import Counter

# Labels dictionary 

labels = ['A','B','C','D','E','F','G','H',]

labelsdict_ltn = {
  'A': '0','B': '1','C': '2','D': '3','E': '4','F': '5','G': '6','H': '7','I': '8','J': '9',
  'K': '10','L': '11','M': '12','N': '13','O': '14','P': '15','Q': '16','R': '17','S': '18',
  'T': '19','U': '20','V': '21','W': '22','X': '23','Y': '24','Z': '25'
}

labelsdict_ntl = inv_map = {v: k for k, v in labelsdict_ltn.items()}    


def parse_args(args):
    """
    It parses the command-line arguments.
    Parameters
    ----------
    args : list[str]
        List of command-line arguments to parse
    Returns
    -------
    parsed_args : argparse.Namespace
        It contains the command-line arguments that are supplied by the user
    """

    parser = argparse.ArgumentParser()

    parser.add_argument("-d", "--directory", type=str, dest = "input_folder",\
        default = 'LIG_Pele', help="Name of the directory where the simulation\
        is located.")
    parser.add_argument("-r", "--residue_name", type=str, dest = "residue_name",\
        default = 'LIG', help="Ligand's residue name.")
    parser.add_argument("-cl", "--clusters_folder", type=str, dest = "clusters_folder",\
        default = 'results', help="Name of the directory containing the folder: clusters.")

    parsed_args = parser.parse_args(args)

    return parsed_args

def linen_correction(input_folder, residue_name, clusters_folder):
    """
    It prepares everything to perform a PELE energy calculation 
    of all the clustered positions of a previous induced fit 
    PELE simulation.

    Parameters
    ----------
    input_folder : str
        The path to the directory created by the induced fit simulation.
    residue_name : str
        Residue name of the ligand in the pdb of each cluster.
    clusters_folder : str
        Name of the directory where the directory clusters is located (results/analysis).
    conf_file_name: str
        Name of the .conf file used to run pele (not adaptive.conf).
    """

    def path_definer(input_folder,
                     residue_name,clusters_folder):

        """
        Defines all the paths that are going to be used

        Parameters
        ----------
        input_folder : str
            The path to the directory created by the induced fit simulation.
        clusters_folder : str
            Name of the directory where the directory clusters is located (results/analysis).

        Returns
        -------
        path_previous_simulation: str
            The path to the directory generated by the simulation we want to analyze the clusters
            from.
        path_clusters : str
            The path to the directory containing the pdbs of the representative poses for each
            cluster.
        path_energies_input : str 
            The path to the generated directory containing the input proportioned.
        path_energies_simulation : str
            The path to the generated directory containing all the necessary files to perform the
            PELE energy calculation.
        """        
        
        path = str(pathlib.Path().absolute())
        path_previous_simulation = path + '/' + input_folder
        path_results = path_previous_simulation + '/' + clusters_folder
        path_output = path_previous_simulation + '/output' 

        if os.path.isdir(path_previous_simulation) == False:
            raise Exception('PathError: There is no folder with this name: ' + path_previous_simulation + '. Please check the path and the folder name.')

        path_energies = path + '/' + residue_name + '_linen'
        path_energies_input = path_energies + '/' + 'input'
        path_energies_simulation = path_energies + '/' + 'simulation'
        path_energies_output = path_energies + '/output'

        if  os.path.exists(path_energies) == False:
            os.mkdir(path_energies)

        if  os.path.exists(path_energies_input) == False:
            os.mkdir(path_energies_input)

        if  os.path.exists(path_energies_simulation) == False:
            os.mkdir(path_energies_simulation)

        if  os.path.exists(path_energies_output) == False:
            os.mkdir(path_energies_output)

        return  path_previous_simulation, path_output, path_results,\
        path_energies_input, path_energies_simulation, path_energies_output

    # Paths        
    _, path_output, path_results, _, path_energies_simulation, path_energies_output\
    = path_definer(input_folder,residue_name,clusters_folder)

    # Copying reports
    if os.path.isdir(path_output):

        files = os.listdir(path_output)

        for folder in files:

            if folder.isnumeric():

                full_path = os.path.join(path_output,folder)
                full_new_path = os.path.join(path_energies_output,folder)

                if os.path.exists(full_new_path) == False:
                    os.mkdir(full_new_path)

            files_subdir = os.listdir(full_path)

            for report in files_subdir:

                if 'report' in report:

                    shutil.copy(os.path.join(full_path,report), full_new_path)    

    # Retrieving cluster information
    cont = 0

    labels_letter = []
    labels = []
    cluster_energy = []
    clustersdict = {}

    with open(os.path.join(path_energies_simulation,'energy.csv')) as filein:

        for line in filein:

            if cont != 0:  

                line = line.split(',')
                labels_letter.append(line[0])
                labels.append(labelsdict_ltn[line[0]])
                cluster_energy.append(line[2])
                clustersdict[line[0]] = float(line[2])


            cont += 1      

    # Retrieving simulation information
    cont = 0

    step = []
    path = []
    cluster = []
    report_paths = []
    report_paths_out = []


    with open(os.path.join(path_results,'data.csv')) as filein:

        for line in filein:

            if cont != 0:
      
                line = line.split(',')      
                line_1 = line[-1].split()[0]


                if any(label == line_1 for label in labels):

                    path_string = line[-2].split('trajectory_')[0]
                    path_string_out = path_string.replace(input_folder,residue_name + '_linen')


                    ###########################################################################

                    path_string = path_string.replace('/gpfs/projects/bsc72/ignasi/PhD/strain/second_set/MTAP/OPLS/normal/1CB0/','/mnt/c/Users/Ignasi/Desktop/Ignasi/Estudis/PhD/code/code_pelissimo/results/')
                    path_string_out = path_string_out.replace('/gpfs/projects/bsc72/ignasi/PhD/strain/second_set/MTAP/OPLS/normal/1CB0/','/mnt/c/Users/Ignasi/Desktop/Ignasi/Estudis/PhD/code/code_pelissimo/results/')

                    ###########################################################################

                    report_num = str(line[-2])
                    report_num = report_num.split('/')[-1]  
                    report_num = report_num.split('.pdb')[0].split('_')[1]

                    step.append(int(line[0]))   
                    cluster.append(int(line[-1].split('\n')[0]))
                    report_paths.append(os.path.join(path_string,'report_' + str(report_num)))    
                    report_paths_out.append(os.path.join(path_string_out,'report_' + str(report_num)))             

            cont += 1


    # Correction 

    report_paths_dictionary = Counter(report_paths)
    report_paths = sorted(report_paths)

    cont_cluster = 0
    cont_paths = 0

    for key in report_paths_dictionary:

        steps_in_report = step[:report_paths_dictionary[key]]
    
        cont = 0

        with open(report_paths_out[cont_paths], 'w') as fileout:

            with open(key) as filein:

                for line in filein:

                    if cont != 0:

                        line = line.split()

                        if int(line[1]) == steps_in_report[0] and len(steps_in_report) > 1:

                            # Using list with all the clusters to obtain number
                            cluster_number = str(cluster[cont_cluster])

                            # Using dictionary from number to letter to obtain letter
                            cluster_letter = labelsdict_ntl[cluster_number]

                            # Using dictionary from letter to energy to obtain energy
                            cluster_energy = clustersdict[cluster_letter]

                            # Recalculating energy
                            line[4] =  str(float(line[4]) - cluster_energy)
                           
                            # Writing
                            fileout.write("     ".join(line) + '\n')

                            # Updating counters
                            steps_in_report = steps_in_report[1:]
                            cont_cluster += 1

                        elif int(line[1]) == steps_in_report[0] and len(steps_in_report) == 1:

                            cluster_number = str(cluster[cont_cluster])
                            cluster_letter = labelsdict_ntl[cluster_number]
                            cluster_energy = clustersdict[cluster_letter]

                            line[4] = str(float(line[4]) - cluster_energy)

                            # Writing
                            fileout.write("     ".join(line) + '\n')

                            cont_cluster += 1
                        
                        else:

                            fileout.write("     ".join(line) + '\n')
                    
                    else:

                        fileout.write(line)


                    cont += 1

            step = step[report_paths_dictionary[key]:]
            cont_paths += 1






def main(args):
    """
    It reads the command-line arguments and runs linen_results.
    Parameters
    ----------
    args : argparse.Namespace
        It contains the command-line arguments that are supplied by the user
    Examples
    --------
    """

    linen_correction(input_folder = args.input_folder,
                     residue_name = args.residue_name,
                     clusters_folder = args.clusters_folder)


if __name__ == '__main__':

    args = parse_args(sys.argv[1:])
    main(args)